Попробуем протестировать стек. Напомню, что стек представляет собой список 
элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, 
а извлекаются в обратном. Сам стек, как правило, используется для реализации 
алгоритмов. Он часто используется в низкоуровневом коде: например, внутри языков 
программирования или в операционных системах.

> Реализация стека: ./../files/src/scripts/stack.js
> Мануальный тест: ./../files/src/scripts/script.js
> Автоматический тест: ./../files/__tests__/1/stack.test.js


Теперь напишем первый тест. Первый тест всегда должен проверять позитивный 
сценарий — тот, в котором задействована основная функциональность 
тестируемого компонента:

> Автоматический тест: ./../files/__tests__/1/stack.test.js

Тест "stack's main flow" проверяет, что правильно работают два основных метода без
учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по 
очереди проверяют извлекаемые значения из стека.

В интернете можно встретить мнение, что несколько проверок в рамках одного теста
это неправильно. Что тесты нужно детализировать максимально подробно и создавать
новый тест на каждую проверку.

> Файл: ./../files/__tests__/1/stack2.test.js.txt

Такой подход нередко приводит к серьёзному раздуванию кода и дублированию. 
А выгода не очевидна. Что по-настоящему надо выделять в отдельный тест, 
так это другой сценарий, которому нужны другие данные и который выполняет 
другую последовательность действий.


> Тестируем дополнительную функциональность

Следующим тестом будет тест на дополнительные функции стека. 
К таким у нас относится функция isEmpty(), которая проверяет, пустой ли стек:

> Файл: ./../files/__tests__/1/stack.test.js
> Тест "isEmpty"

В этом тесте проверяются сразу три ситуации:

- начальное состояние стека
- состояние стека после добавления элементов
- состояние стека после извлечения всех элементов

В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых isEmpty()
всё равно сломается. Нужно ли пытаться найти все варианты? Не нужно. Тесты не даются
бесплатно, каждая написанная строчка кода в проекте — потенциальное место для
изменения в случае правок. Если есть сомнения, нужно ли писать проверку или нет,
то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после
которого тесты писать не эффективно. Редкие ситуации требуют покрытия тестами только
тогда, когда они критичны для работоспособности.


> Пограничные случаи

Ну, и последнее, что можно протестировать — поведение функции pop(), когда в 
стеке нет ни одного элемента. По задумке, стек выбрасывает исключение, если 
из него попытались взять элемент, когда тот был пустой. То есть эта ситуация 
рассматривается как ошибочная, программист всегда должен убеждаться в том что 
стек не пустой.

> Файл: ./../files/__tests__/1/stack.test.js
> Тест "pop in empty stack"

Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой 
программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, 
для которой не было теста, то сначала напишите тест, который воспроизводит эту 
ошибку, и затем уже чините её. Только так можно поддерживать достаточный уровень 
надёжности, не превращая разработку в непрерывную починку багов.

Доп. https://guides.hexlet.io/check-list-of-engineering-practices/