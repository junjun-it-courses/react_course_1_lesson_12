> Подготовка данных

Большинство тестов на одну и ту же функциональность сильно похожи друг на друга. 
Особенно в части начальной подготовки данных. В прошлом случае каждый тест начинался 
со строчки: makeStack(). Это ещё не дублирование, но уже шаг в эту сторону. 
Как правило, реальные тесты сложнее и включают в себя большую подготовительную работу.

Допустим, мы разрабатываем библиотеку <a href="https://lodash.com/">Lodash</a> и хотим протестировать её функции для 
обработки коллекций:

- find
- filter
- includes
- и другие (всего их около 20 штук)

Для работы этих функций нужна заранее подготовленная коллекция. 
Проще всего придумать одну, которая подойдёт для тестирования большинства
или даже всех функций:

> Файл ./../files/tests/2/lodash.test.js

Теперь представьте, что таких тестов несколько десятков (в реальности их сотни).
Код начнёт кочевать из одного места в другое, порождая всё больше и больше копипасты.

Самый простой способ избежать этого — вынести определение коллекции на уровень 
модуля, вне тестовых функций:

> Файл ./../files/tests/2/lodash2.test.js

Это простое решение убирает ненужное дублирование. Однако учтите, оно работает 
только в рамках одного модуля. Подобную коллекцию всё равно придётся определять в 
каждом тестовом модуле. И в нашем случае это скорее плюс, а не минус.

Дело в том, что излишнее обобщение, приводящее к полному устранению дублирования, 
вводит неявные зависимости в код. Изменение этой коллекции почти наверняка приведёт 
к поломке большинства тестов, которые завязаны на её структуру, на количество 
элементов и их значения:

> Файл ./../files/tests/2/lodash3.test.js
 
Тест выше сломается, если мы добавим в нашу коллекцию еще одно чётное число.
А коллекцию почти наверняка придётся расширять при добавлении новых тестов 
(для этой же или других функций).

Главный вывод из этого: устранять дублирование надо. Но важно не перейти границу, 
после которой обобщение начинает больше мешать, чем помогать.

Но далеко не всегда можно выносить константы на уровень модуля. В первую очередь 
это касается динамических данных. Представьте себе такой код:

> Файл ./../files/tests/2/dynamic_data.test.js

Подвох тут в том, что модуль загружается в память ровно один раз. Это значит, что 
весь код, определённый на уровне модуля (включая константы), выполняется ровно один
раз. В примере константа now определится до запуска всех тестов, и только затем jest
начнёт выполнять тесты. И с каждым последующим тестом отставание значения константы
now от текущего реального значения "сейчас" будет всё дальше и дальше.

Почему это может быть проблемой? Код, который работает с понятием "сейчас", может
рассчитывать на то, что "сейчас" это почти моментальный снимок данного момента 
времени. Но в примере выше, сейчас начинает отставать от реального сейчас и чем
больше тестов и чем они сложнее, тем большее отставание.

Важно не забыть: функция test не запускает тест на выполнение. Она добавляет его
во внутрь Jest, а вот он уже решает, когда выполнить этот тест. Поэтому между 
загрузкой модуля и отработкой тестов проходит неопределённое время.

Для решения этой проблемы тестовые фреймворки предоставляют хуки — специальные 
функции, которые запускаются до или после тестов. Ниже пример того, как создавать
дату перед каждым тестом:

> Файл ./../files/tests/2/dynamic_data2.test.js

beforeEach(callback) принимает на вход функцию, внутри которой выполняется 
инициализирующее действие. Оно не обязательно приводит к созданию переменных. 
Возможно, инициализация заключается в подготовке файловой системы, например, 
создании файлов.

Но если она должна создать данные и сделать их доступными в тестах, то придётся 
использовать переменные, определённые на уровне модуля. Так как всё, что определяется
внутри функций (колбека в нашем случае), остаётся внутри этой функции.

Даже если нам нужно выполнить код один раз перед всеми тестами, его все равно нужно
выполнять не на уровне модуля, а внутри хука beforeAll(callback). Этот хук 
запускается ровно один раз перед всеми тестами, расположенными в одном модуле.

> Файл ./../files/tests/2/dynamic_data3.test.js.txt

Все, что вызывается на уровне модуля, отрабатывает вне Jest. Это значит, 
что Jest никак не может отследить, что происходит, и в какой момент можно запускать
тесты.

Доп. https://jestjs.io/docs/api#methods